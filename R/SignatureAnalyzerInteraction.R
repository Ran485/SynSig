# SignatureAnalyzer_interaction.R

library(data.table)

#####################################################################
# Functions to read SignatureAnalyzer signature catalogs from disk
# into standard in-memory representations.
#####################################################################

#' Functions to canonicalize mutation type names
#'
#' \code{CanonicalizeSAx} For 96 and 1536 SNSs.
#'
#' \code{CanonicalizeSADBS} For 78 DNS (doublet substitutions).
#'
#' \code{CanonicalizeSAID} For indels.
#'
#' @return Mutation type names in canonical in-memory format.
#'
#' @name CanonicalizeSAMutTypes
NULL

#' @rdname CanonicalizeSAMutTypes
#' @keywords internal
CanonicalizeSAx <- function(feature.names) {
  xx <-
    as.matrix(data.frame(strsplit(feature.names,
                                  "_at_",
                                  fixed = TRUE)))
  ref.gt.var       <- xx[1, ]
  before.ref.after <- xx[2, ]
  var <- substring(ref.gt.var, 3, 3)
  return(paste0(before.ref.after, var))
}

#' @rdname CanonicalizeSAMutTypes
#' @keywords internal
CanonicalizeSADBS <- function(feature.names) {
  return(sub(">", "", feature.names, fixed = TRUE))
}

#' @rdname CanonicalizeSAMutTypes
#' @keywords internal
CanonicalizeSAID <- function(feature.names) {
  return(gsub("_", ":", feature.names, fixed = TRUE))
}

#' Read signatures in SignatureAnalyzer format as found on
#' the PCAWG7 Synapse web site.
#'
#' @param path File to read
#'
#' @param canonicalize.rows A function to get the rownames and put the rows
#'                      in the correct order.
#'
#' @param exp.nrow          Expected number of rows. Stop if the actual
#'                      number of rows in path is different.
#'
#' @param row.order         Canonical row order for these mutation types.
#'
#' @return   A catalog of spectra or signatures in canonical in-memory format.
#'
#' @importFrom data.table fread
#'
#' @keywords internal
ReadAnySASig <- function(path, canonicalize.rows, exp.nrow, row.order) {
  dt <- as.data.frame(fread(path))
  stopifnot(nrow(dt) == exp.nrow)
  feature <- which(names(dt) == "feature")
  feature.names <- dt[ , feature]
  dt <- dt[ , -1 * feature]

  rownames(dt) <- canonicalize.rows(feature.names)

  out <- dt[row.order, ]

  return(as.matrix(out))
}

#' Read SignatureAnalyzer signatures from PCAWG7 / Synapse.
#'
#' There is no custom catalog reading function for SignatureAnalyzer.
#'
#' \code{ReadSASig96} Read a 96 SNS catalog from path
#'
#' \code{ReadSASig1536} Read a 1536 SNS catalog from path
#'
#' \code{ReadSASigDBS} Read a 78 DNS catalog from path
#'
#' \code{ReadSASigID} Read a ID (insertion/deletion) catalog from path
#' Please take note that deletion Repeat Size ranges from 0 to 5+
#' in the catalog, but for plotting and end user documentation
#' it ranges from 1 to 6+.
#'
#' @param path The file to read from.
#'
#' @seealso \code{\link{ReadSASigCOMPOSITE}}
#'
#' @return A catalog in canonical in-memory format.
#'
#' @name ReadSASig
NULL

#' @rdname ReadSASig
#' @export
ReadSASig96 <- function(path) {
  ReadAnySASig(path, CanonicalizeSAx, 96, ICAMS:::.catalog.row.order96)
}

#' @rdname ReadSASig
#' @export
ReadSASig1536 <- function(path) {
  ReadAnySASig(path, CanonicalizeSAx, 1536,
               ICAMS:::.catalog.row.order1536)
}

#' @rdname ReadSASig
#' @export
ReadSASigDBS <- function(path) {
  ReadAnySASig(path, CanonicalizeSADBS, 78,
               ICAMS:::.catalog.row.order.DNS.78)
}

#' @rdname ReadSASig
#' @export
ReadSASigID <- function(path) {
  ReadAnySASig(path, CanonicalizeSAID, 83,
               ICAMS:::.catalog.row.order.ID)
}

#' Read SignatureAnalyzer COMPOSITE signatures from fixed files
#'
#' @return A matrix (data.frame?) of COMPOSITE signatures
#'
#' @export
ReadSASigCOMPOSITE <- function() {

  sa1536.file <-
    "SignatureAnalyzer_COMPOSITE_SBS_W1536.signature.031918.txt"
  saDBS.file  <-
    "SignatureAnalyzer_COMPOSITE_DBS.signature.042018.txt"
  saID.file   <-
    "SignatureAnalyzer_COMPOSITE_ID.signature.031918.txt"

  sa1536.sig  <- ReadSASig1536(sa1536.file)
  saDBS.sig   <- ReadSASigDBS(saDBS.file)
  saID.sig    <- ReadSASigID(saID.file)

  colnames(sa1536.sig) <-
    sub("_SNV", "", colnames(sa1536.sig), fixed = TRUE)
  colnames(saDBS.sig)  <-
    sub("_DNP", "", colnames(saDBS.sig), fixed = TRUE)
  colnames(saID.sig)   <-
    sub("_INDEL", "", colnames(saID.sig), fixed = TRUE)
  stopifnot(colnames(sa1536.sig) == colnames(saDBS.sig))
  stopifnot(colnames(sa1536.sig) == colnames(saID.sig))
  return(rbind(sa1536.sig, saDBS.sig, saID.sig))
}

#' Read a COMPOSITE catalog
#'
#' A COMPOSITE catalog is an rbind
#' of a 1536 catalog, a DBS catalog, and an ID catalog.
#' This function does not read SignatureAnalyzer
#' signatures as found on the PCAWG7 Synapse web
#' site, but rather
#' as generated by this package.
#'
#' @seealso \code{\link{WriteCatCOMPOSITE}}
#'
#' @param path Path of the file to read from.
#'
#' @param strict For comaptibility with other ReadCat functions; ignored.
#'
#' @return An in memory matrix corresponding to the
#' contents of the file at \code{path}.
#'
#' @importFrom utils read.csv
#' @export
ReadCatCOMPOSITE <- function(path, strict = FALSE) {
  retval <- read.csv(path, header = T, row.names = 1)
  return(as.matrix(retval))
}

#' Write a COMPOSITE catalog or signature matrix to disk
#'
#' @param ct A catalog or signature matrix
#'
#' @param path Path to file to write
#'
#' @importFrom utils write.csv
#'
#' @seealso \code{\link{ReadCatCOMPOSITE}}
#'
#' @export
#'
WriteCatCOMPOSITE <- function(ct, path) {
  write.csv(ct, file = path, row.names = TRUE,
            quote = FALSE)
}

#' Prepare input data for SignatureAnalyzer
#'
#' @param cat96 Input catalog in in standard in-memory format
#'
#' @return Catalog in in-memory format expected by SignatureAnalyzer
#'
#' @export
SACat96 <- function(cat96) {
  stopifnot(nrow(cat96) == 96)
  SA.96.row.order <-
    c("TGTT", "TGGT", "TGCT", "TGAT", "TGTG", "TGGG", "TGCG", "TGAG",
      "TGTC", "TGGC", "TGCC", "TGAC", "TGTA", "TGGA", "TGCA", "TGAA",
      "TCTT", "TCGT", "TCCT", "TCAT", "TCTG", "TCGG", "TCCG", "TCAG",
      "TCTC", "TCGC", "TCCC", "TCAC", "TCTA", "TCGA", "TCCA", "TCAA",
      "TATT", "TAGT", "TACT", "TAAT", "TATG", "TAGG", "TACG", "TAAG",
      "TATC", "TAGC", "TACC", "TAAC", "TATA", "TAGA", "TACA", "TAAA",
      "CAAA", "CAAC", "CAAG", "CAAT", "CACA", "CACC", "CACG", "CACT",
      "CAGA", "CAGC", "CAGG", "CAGT", "CATA", "CATC", "CATG", "CATT",
      "CGAA", "CGAC", "CGAG", "CGAT", "CGCA", "CGCC", "CGCG", "CGCT",
      "CGGA", "CGGC", "CGGG", "CGGT", "CGTA", "CGTC", "CGTG", "CGTT",
      "CTAA", "CTAC", "CTAG", "CTAT", "CTCA", "CTCC", "CTCG", "CTCT",
      "CTGA", "CTGC", "CTGG", "CTGT", "CTTA", "CTTC", "CTTG", "CTTT"
    )
  rn <-rownames(cat96)
  crn <- function(rn) {
    x <-unlist(strsplit(rn, ""))
    paste(x[c(2, 4, 1, 3)], collapse = "")
  }
  nrn <- lapply(rn, crn)
  rownames(cat96) <- nrn
  cat96 <- cat96[SA.96.row.order, ]
  return(cat96)
}

#####################################################################
# Miscellaneous addtional SignatureAnalyzer-related functions
#####################################################################

#' Plot the SBS96 part of a SignatureAnalyzer COMPOSITE signature or catalog
#'
#' TODO(Steve): Deal with Collapse1536to96
#'
#' @param catalog Catalog or signature matrix
#'
#' @param name Name of file to print to.
#'
#' @param type See \code{\link[ICAMS]{Cat96ToPdf}}.
#'
#' @importFrom ICAMS Cat96ToPdf
#' @export
#'
Plot96PartOfComposite <- function(catalog, name, type = "density") {
  cat1536 <- catalog[1:1536, ]
  cat96 <- ICAMS:::Collapse1536To96(cat1536)
  all.0 <- which(colSums(cat96) == 0)
  if (length(all.0) > 0 ) {
    cat96[ , all.0] <- 1
    cn <- colnames(cat96)
    cn[all.0] <- paste(cn[all.0], "WARNING all 0")
    colnames(cat96) <- cn
  }
  Cat96ToPdf(catalog = cat96/sum(cat96), name = name, type = type)
}

#' Standardize SignatureAnalyzer signature names
#'
#' For example, change \code{BI_COMPOSITE_SNV_SBS83_P}
#' to \code{BI_COMPOSITE_SBS83_P}
#'
#' @param sig.names Vector of signature names
#'
#' @return Vector of signatures names with "_SNV" removed.
#'
#' @export
FixSASigNames <- function(sig.names) {
  return(gsub("_SNV_", "_", sig.names, fixed = TRUE))
}

# Add this doc to the signature name fixup for SA:
#
# . This is necessary because
#' for COMPOSITE signatures we rbind coordinated
#' "SNV", "DNP", and "INDEL" signatures. See
#' \code{\link{ReadSASigCOMPOSITE}}.


#' Function for running SignatureAnalyzer on a file containing
#' a catalog.
#'
#' Normally, please call \code{\link{SignatureAnalyzerOneRun}}
#' instead of this function.
#'
#' @param input.catalog File containing input catalog.  Columns are
#' samples (tumors), rows are signatures.  SignatureAnalyzer does
#' not care about the row names (I think) TODO(Steve): check this.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Directory that will be created for the output;
#' abort if it already exits.  Log files will be in
#' \code{paste0(out.dir, "/tmp")}.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param input.exposures A file with the synthetic exposures used to generate
#' \code{input.catalog}; if provided here,
#' this is copied over to the output directory
#' for downstream analysis.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE, overwrite existing output
#'
#' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.H} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }
#'
#' @details Creates several
#'  files in \code{paste0(out.dir, "/sa.output.rdata")}. These are
#'  TODO(Steve): list the files
#'
#' @export
#'
#' @importFrom utils capture.output
#'
RunSignatureAnalyzerOnFile <-
  function(input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE) {

    syn.data <- read.catalog.function(input.catalog,
                                      strict = FALSE)

    if (test.only) syn.data <- syn.data[ , 1:10]

    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir)
    }
    # TEMPORARY is a global required by SignatureAnalyzer
    TEMPORARY <<- paste0(out.dir, "/tmp/")
    if (dir.exists(TEMPORARY)) {
      if (!overwrite) stop("Directory ", TEMPORARY, " already exists")
    } else {
      dir.create(TEMPORARY)
    }
    # BayesNMF.L1W.L2H is defined by the statement
    # source("SignatureAnalyzer.PCAWG.function.R") above.
    capture.output(
      out.data <-
        BayesNMF.L1W.L2H(syn.data, 200000, 10, 5, tol, maxK, maxK, 1),
      file = paste0(TEMPORARY, "captured.output.txt"))

    sigs <- out.data[[1]]
    sigs <- sigs[   , colSums(sigs) > 1]

    exp <- out.data[[2]]
    exp <- exp[colnames(sigs), ]

    names(out.data) <- c("signatures.W", "exposures.H",
                         "likelihood", "evidence",
                         "relevance", "error")

    # Save in native R format.
    save(out.data, sigs,
         file = paste0(out.dir, "/sa.output.rdata"))

    write.signature.function(sigs,
                             paste0(out.dir, "/sa.output.sigs.csv"))

    WriteExposure(exp, file = paste0(out.dir, "/sa.output.exp.csv"))

    if (!is.null(input.exposures)) {
      WriteExposure(ReadExposure(input.exposures),
                    file = paste0(out.dir, "/input.syn.exp.csv"))
    }

    other.data <- paste0(out.dir, "/sa.output.other.data.csv")

    cat("num.sigs,", ncol(sigs), "\n", sep = "", file = other.data)
    cat("likelihood,", out.data$likelihood, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("evidence,", out.data$evidence, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("relevance,",
        paste(out.data$relevance, collapse = ","), "\n",
        sep = "", file = other.data, append = TRUE)
    cat("error,", out.data$error, "\n",
        sep = "", file = other.data, append = TRUE)

    if (delete.tmp.files) unlink(TEMPORARY, recursive = TRUE)

    invisible(out.data)
  }

#' Run SignatureAnalyzer once on a single data set and put results
#' in specified location.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog Path to the file containing the catalog
#' of mutational spectra.
#'
#' @param read.catalog.function Function to read \code{input.catalog}.
#'
#' @param out.dir Location to put the output; must not already exist; it
#' will be created.
#'
#' @param write.signature.function Function to write the extracted
#' signatures to a file.
#'
#' @param input.exposures Exposures from which the spectra in
#' \code{input.catalog} were generated.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param verbose If > 0, write some tracing and timing information.
#'
#' @param overwrite If TRUE overwrite preexisting results.
#'
SignatureAnalyzerOneRun <-
  function(signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           verbose = 1,
           overwrite = FALSE)
{
  options( warn = 0 )
  here <- getwd()
  setwd(signatureanalyzer.code.dir)
  INPUT <<- "INPUT_SignatureAnalyzer/"
  suppressPackageStartupMessages(
    source("SignatureAnalyzer.PCAWG.function.R")
  )
  setwd(here) # This is necessary because the caller
  # as specified input and output locations
  # realtive to here.

  if (verbose)
    cat("Running SignatureAnalyzerOneRun in", here, out.dir, "\n")
  retval <-
    RunSignatureAnalyzerOnFile(
      input.catalog = input.catalog,
      read.catalog.function = read.catalog.function,
      out.dir = out.dir,
      write.signature.function = write.signature.function,
      input.exposures = input.exposures,
      maxK = maxK,
      tol = tol,
      test.only = test.only,
      delete.tmp.files = delete.tmp.files,
      overwrite = overwrite)

  invisible(retval)

}

#' Run SignatureAnalyzer on one catalog and put results
#' in specified location.
#'
#' @param num.runs The number of times run SignatureAnalyzer on each
#' catalog (matrix of mutational spectra).
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog The catalog to analyze.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Root of directory tree that will contain the
#' results.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE overwrite previous results in same directory tree.
#'
#' @param mc.cores Number of cores to use for \code{mclapply}; ignored on
#' Windows.
#'
#' @importFrom parallel mclapply
#'
#' @export
SignatureAnalyzerOneCatalog <-
  function(num.runs,
           signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE,
           mc.cores = 1) {

    if (!dir.exists(out.dir)) dir.create(out.dir)
    else warning(out.dir, "exists, overwriting")

    RunOneIndex <- function(i) {
      out.dir2 <- paste0(out.dir, "sa.run.", i)
      SignatureAnalyzerOneRun(
        signatureanalyzer.code.dir = signatureanalyzer.code.dir,
        input.catalog = input.catalog,
        read.catalog.function = read.catalog.function,
        out.dir = out.dir2,
        write.signature.function = write.signature.function,
        maxK = maxK,
        tol = tol,
        test.only = test.only,
        delete.tmp.files = delete.tmp.files,
        overwrite = overwrite)
      return(paste0("Success for ", out.dir, out.dir2))
    }

    mc.cores.to.use <-
      ifelse(Sys.info()["sysname"] == "Windows", 1, mc.cores)

    cat("Using", mc.cores.to.use, " cores\n")

    mc.output <-
      mclapply(1:num.runs, FUN = RunOneIndex, mc.cores = mc.cores.to.use)

    print(str(mc.output))

    return(paste0("results in ",  out.dir, "sa.run.*"))
  }

#' Run SignatureAnalyzer on 4 coordinated data sets and put results
#' in specified location.
#'
#' @details The 4 coordinated data sets are
#'
#' \enumerate{
#' \item \code{sa.sa.96}
#'
#' \item \code{sp.sp}
#'
#' \item \code{sa.sa.COMPOSITE}
#'
#' \item \code{sp.sa.COMPOSITE}
#'
#' }
#' which are described elsewhere.
#'
#'
#' @param num.runs Number of SignatureAnalyzer runs per data set.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param dir.root Root of directory tree that contains the
#' input data and to which the results will be written.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param slice Vector of integers from 1:4. Only run on the
#' corresponding data set (see Details).
#'
#' @param overwrite if TRUE overwrite preexisting results.
#'
#' @param mc.cores The number of cores to use with \code{mclapply};
#' ignored on Windows.
#'
#' @export
#'
#' @importFrom ICAMS WriteCat96
SignatureAnalyzer4MatchedCatalogs <-
  function(
    num.runs = 20,
    signatureanalyzer.code.dir,
    dir.root,
    maxK = 30,
    tol = 1e-7,
    test.only = FALSE,
    delete.tmp.files = TRUE,
    slice = 1:4,
    overwrite = FALSE,
    mc.cores = 1) {

    if (!dir.exists(dir.root)) stop(dir.root, "does not exist")

    subdirs <- c("sa.sa.96", "sp.sp", "sa.sa.COMPOSITE", "sp.sa.COMPOSITE")
    read.fn <- c(ReadCat96, ReadCat96, ReadCatCOMPOSITE, ReadCatCOMPOSITE)
    write.fn <- c(WriteCat96, WriteCat96, WriteCatCOMPOSITE, WriteCatCOMPOSITE)

    tmp.fn <- function(subdir, read.fn, write.fn) {
      retval1 <-
        SignatureAnalyzerOneCatalog(
          num.runs = num.runs,
          signatureanalyzer.code.dir = signatureanalyzer.code.dir,
          input.catalog = paste0(dir.root, "/", subdir, "/ground.truth.syn.catalog.csv"),
          read.catalog.function = read.fn,
          out.dir = paste0(dir.root, "/", subdir, "/sa.results/"),
          write.signature.function = write.fn,
          maxK = maxK,
          tol = tol,
          test.only = test.only,
          delete.tmp.files = delete.tmp.files,
          overwrite = overwrite,
          mc.cores = mc.cores)
    }

  retval2 <-
    mapply(tmp.fn, subdirs[slice], read.fn[slice], write.fn[slice])

  invisible(retval2)
  }

#' Summarize all subdirs of a major dataset.
#'
#' @param top.level.dir Path to top level directory.
#'
#' @param overwrite If true overwite existing summary files.
#'
#' @export
SignatureAnalyzerSummarizeTopLevel <-
  function(top.level.dir, overwrite = FALSE) {
    stopifnot(dir.exists(top.level.dir))

    sa.sa.96.dir <- paste0(top.level.dir, "/sa.sa.96/sa.results")
    stopifnot(dir.exists(sa.sa.96.dir))
    sp.sp.dir <- paste0(top.level.dir, "/sp.sp/sa.results")
    stopifnot(dir.exists(sp.sp.dir))
    sa.sa.COMPOSITE.dir <-
      paste0(top.level.dir, "/sa.sa.COMPOSITE/sa.results")
    stopifnot(dir.exists(sa.sa.COMPOSITE.dir))
    sp.sa.COMPOSITE.dir <-
      paste0(top.level.dir, "/sp.sa.COMPOSITE/sa.results")
    stopifnot(dir.exists(sp.sa.COMPOSITE.dir))

    CopyBestSignatureAnalyzerResult(sa.sa.96.dir, overwrite = overwrite)
    CopyBestSignatureAnalyzerResult(sp.sp.dir, overwrite = overwrite)
    CopyBestSignatureAnalyzerResult(sa.sa.COMPOSITE.dir, overwrite = overwrite)
    CopyBestSignatureAnalyzerResult(sp.sa.COMPOSITE.dir, overwrite = overwrite)

    retval <-
      list(sa.sa.96 =
             SummarizeSigOneSA96Subdir(sa.sa.96.dir),
           sp.sp =
             SummarizeSigOneSA96Subdir(sp.sp.dir),
           sa.sa.COMPOSITE =
             SummarizeSigOneSACOMPOSITESubdir(sa.sa.COMPOSITE.dir),
           sp.sp.COMPOSITE =
             SummarizeSigOneSACOMPOSITESubdir(sp.sa.COMPOSITE.dir))

    capture.output(print(retval), file = paste0(top.level.dir, "/summary.txt"))
    invisible(retval)
  }

# SignatureAnalyzerInteraction.R

#' Read a COMPOSITE catalog
#'
#' A COMPOSITE catalog is an rbind
#' of a 1536 catalog, a DBS catalog, and an ID catalog.
#' This function does not read SignatureAnalyzer
#' signatures as found on the PCAWG7 Synapse web
#' site, but rather
#' as generated by this package for analysis by
#' SignatureAnalyzer.
#'
#' @seealso \code{\link{WriteCatCOMPOSITE}}
#'
#' @param path Path of the file to read from.
#'
#' @param strict For compatibility with other \code{ReadCat} functions; ignored.
#'
#' @return An in memory matrix corresponding to the
#' contents of the file at \code{path}.
#'
#' @importFrom utils read.csv
#'
#' @keywords internal

ReadCatCOMPOSITE <- function(path, strict = FALSE) {
  retval <- read.csv(path, header = T, row.names = 1)
  return(as.matrix(retval))
}

#' Write a COMPOSITE catalog or signature matrix to disk
#'
#' @param ct A catalog or signature matrix
#'
#' @param path Path to file to write
#'
#' @importFrom utils write.csv
#'
#' @seealso \code{\link{ReadCatCOMPOSITE}}
#'
#' @export
# Exported because of Create.pancreas.Rmd, Create.2.7a.7b.Rmd, etc.

WriteCatCOMPOSITE <- function(ct, path) {
  write.csv(ct, file = path, row.names = TRUE,
            quote = FALSE)
}


#' Standardize SignatureAnalyzer signature names
#'
#' For example, change \code{BI_COMPOSITE_SNV_SBS83_P}
#' to \code{BI_COMPOSITE_SBS83_P}
#'
#' This is necessary because
#' for COMPOSITE signatures we rbind coordinated
#' "SNV", "DNP", and "INDEL" signatures.
#'
#' @param sig.names Vector of signature names
#'
#' @return Vector of signatures names with "_SNV" removed.
#'
#' @export

FixSASigNames <- function(sig.names) {
  return(gsub("_SNV_", "_", sig.names, fixed = TRUE))
}


#' Prepare input data for SignatureAnalyzer
#'
#' @param cat96 Input catalog in in standard in-memory format
#'
#' @return Catalog in in-memory format expected by SignatureAnalyzer
#'
#' @keywords internal

SACat96 <- function(cat96) {
  stopifnot(nrow(cat96) == 96)
  SA.96.row.order <-
    c("TGTT", "TGGT", "TGCT", "TGAT", "TGTG", "TGGG", "TGCG", "TGAG",
      "TGTC", "TGGC", "TGCC", "TGAC", "TGTA", "TGGA", "TGCA", "TGAA",
      "TCTT", "TCGT", "TCCT", "TCAT", "TCTG", "TCGG", "TCCG", "TCAG",
      "TCTC", "TCGC", "TCCC", "TCAC", "TCTA", "TCGA", "TCCA", "TCAA",
      "TATT", "TAGT", "TACT", "TAAT", "TATG", "TAGG", "TACG", "TAAG",
      "TATC", "TAGC", "TACC", "TAAC", "TATA", "TAGA", "TACA", "TAAA",
      "CAAA", "CAAC", "CAAG", "CAAT", "CACA", "CACC", "CACG", "CACT",
      "CAGA", "CAGC", "CAGG", "CAGT", "CATA", "CATC", "CATG", "CATT",
      "CGAA", "CGAC", "CGAG", "CGAT", "CGCA", "CGCC", "CGCG", "CGCT",
      "CGGA", "CGGC", "CGGG", "CGGT", "CGTA", "CGTC", "CGTG", "CGTT",
      "CTAA", "CTAC", "CTAG", "CTAT", "CTCA", "CTCC", "CTCG", "CTCT",
      "CTGA", "CTGC", "CTGG", "CTGT", "CTTA", "CTTC", "CTTG", "CTTT"
    )
  rn <-rownames(cat96)
  crn <- function(rn) {
    x <-unlist(strsplit(rn, ""))
    paste(x[c(2, 4, 1, 3)], collapse = "")
  }
  nrn <- lapply(rn, crn)
  rownames(cat96) <- nrn
  cat96 <- cat96[SA.96.row.order, ]
  return(cat96)
}

#' Plot the SBS96 part of a SignatureAnalyzer COMPOSITE signature or catalog
#'
#' @param catalog Catalog or signature matrix
#'
#' @param name Name of file to print to.
#'
#' @param type See \code{\link[ICAMS]{PlotCatalogToPdf}}.
#'
#' @importFrom ICAMS PlotCatSNS96ToPdf Collapse1536To96
#'
#' @keywords internal

Plot96PartOfComposite <- function(catalog, name, type = "density") {
  cat1536 <- catalog[1:1536, ]
  cat96 <- Collapse1536To96(cat1536)
  all.0 <- which(colSums(cat96) == 0)
  if (length(all.0) > 0 ) {
    cat96[ , all.0] <- 1
    cn <- colnames(cat96)
    cn[all.0] <- paste(cn[all.0], "WARNING all 0")
    colnames(cat96) <- cn
  }
  PlotCatSNS96ToPdf(catalog = cat96/sum(cat96), filename = name, type = type)
}


#' Run SignatureAnalyzer on a file containing a catalog.
#'
#' Normally, please call \code{\link{SignatureAnalyzerOneRun}}
#' instead of this function.
#'
#' @param input.catalog File containing input catalog.  Columns are
#' samples (tumors), rows are signatures.  SignatureAnalyzer does
#' not care about the row names (I think) TODO(Steve): check this.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Directory that will be created for the output;
#' abort if it already exits.  Log files will be in
#' \code{paste0(out.dir, "/tmp")}.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param input.exposures A file with the synthetic exposures used to generate
#' \code{input.catalog}; if provided here,
#' this is copied over to the output directory
#' for downstream analysis.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE, overwrite existing output
#'
#' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.H} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }
#'
#' @details Creates several
#'  files in \code{paste0(out.dir, "/sa.output.rdata")}. These are
#'  TODO(Steve): list the files
#'
#' @export
#'
#' @importFrom utils capture.output

RunSignatureAnalyzerOnFile <-
  function(input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE) {

    syn.data <- read.catalog.function(input.catalog,
                                      strict = FALSE)

    if (test.only) syn.data <- syn.data[ , 1:10]

    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exits")
    } else {
      dir.create(out.dir)
    }
    # TEMPORARY is a global required by SignatureAnalyzer
    TEMPORARY <<- paste0(out.dir, "/tmp/")
    if (dir.exists(TEMPORARY)) {
      if (!overwrite) stop("Directory ", TEMPORARY, " already exists")
    } else {
      dir.create(TEMPORARY)
    }

    suppressWarnings(
      # The suppressed warnings relate to some deprecated
      # plotting options used by SignatureAnalyzer.
      capture.output(
        # BayesNMF.L1W.L2H is defined by the statement
        # source("SignatureAnalyzer.PCAWG.function.R") above.
        out.data <-
          BayesNMF.L1W.L2H(syn.data, 200000, 10, 5, tol, maxK, maxK, 1),
        file = paste0(TEMPORARY, "captured.output.txt")))

    sigs <- out.data[[1]]
    sigs.to.use <- which(colSums(sigs) > 1 )
    sigs <- sigs[   , sigs.to.use]

    new.names <- paste0("W.", 1:ncol(sigs))
    colnames(sigs) <- new.names

    exp <- out.data[[2]]
    exp <- exp[sigs.to.use, ]
    rownames(exp) <- new.names

    names(out.data) <- c("signatures.W", "exposures.H",
                         "likelihood", "evidence",
                         "relevance", "error")

    write.signature.function(sigs,
                             paste0(out.dir, "/sa.output.sigs.csv"))

    WriteExposure(exp, file = paste0(out.dir, "/sa.output.exp.csv"))

    if (!is.null(input.exposures)) {
      WriteExposure(ReadExposure(input.exposures),
                    file = paste0(out.dir, "/input.syn.exp.csv"))
    }

    other.data <- paste0(out.dir, "/sa.output.other.data.csv")

    cat("num.sigs,", ncol(sigs), "\n", sep = "", file = other.data)
    cat("likelihood,", out.data$likelihood, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("evidence,", out.data$evidence, "\n",
        sep = "", file = other.data, append = TRUE)
    cat("relevance,",
        paste(out.data$relevance, collapse = ","), "\n",
        sep = "", file = other.data, append = TRUE)
    cat("error,", out.data$error, "\n",
        sep = "", file = other.data, append = TRUE)

    if (delete.tmp.files) unlink(TEMPORARY, recursive = TRUE)

    invisible(out.data)
  }

#' Run SignatureAnalyzer once on a single data set and put results
#' in specified location.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog Path to the file containing the catalog
#' of mutational spectra.
#'
#' @param read.catalog.function Function to read \code{input.catalog}.
#'
#' @param out.dir Location to put the output; must not already exist; it
#' will be created.
#'
#' @param write.signature.function Function to write the extracted
#' signatures to a file.
#'
#' @param input.exposures Exposures from which the spectra in
#' \code{input.catalog} were generated.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param verbose If > 0, write some tracing and timing information.
#'
#' @param overwrite If TRUE overwrite preexisting results.
#'
#' #' @return The output of SignatureAnalyzer, invisibly. This is a list
#' with five elements (named in this code, not by SignatureAnalyzer):
#' \enumerate{
#'  \item \code{signatures.W} The signature matrix
#'  \item \code{exposures.H} The corresponding exposures
#'  \item \code{likelihood} The likelihood
#'  \item \code{evidence} -1 * the posterior probability
#'  \item \code{relevance} One for each column of the \code{signatures.W}
#'  \item \code{error} A measure of reconstruction error (?)
#' }

SignatureAnalyzerOneRun <-
  function(signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           input.exposures = NULL,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           verbose = 0,
           overwrite = FALSE)
{
  options( warn = 0 )
  here <- getwd()
  setwd(signatureanalyzer.code.dir)
  INPUT <<- "INPUT_SignatureAnalyzer/"
  suppressPackageStartupMessages(
    source("SignatureAnalyzer.PCAWG.function.R")
  )
  setwd(here) # This is necessary because the caller
  # as specified input and output locations
  # realtive to here.

  if (verbose)
    cat("Running SignatureAnalyzerOneRun in", here, out.dir, "\n")
  retval <-
    RunSignatureAnalyzerOnFile(
      input.catalog = input.catalog,
      read.catalog.function = read.catalog.function,
      out.dir = out.dir,
      write.signature.function = write.signature.function,
      input.exposures = input.exposures,
      maxK = maxK,
      tol = tol,
      test.only = test.only,
      delete.tmp.files = delete.tmp.files,
      overwrite = overwrite)

  invisible(retval)
}

#' Run SignatureAnalyzer many times on one catalog and put results
#' in specified location.
#'
#' @param num.runs The number of times run SignatureAnalyzer on each
#' catalog (matrix of mutational spectra).
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param input.catalog The catalog to analyze.
#'
#' @param read.catalog.function Function taking a file path as
#' its only argument and returning a catalog as a numeric matrix.
#'
#' @param out.dir Root of directory tree that will contain the
#' results.
#'
#' @param write.signature.function Function with first argument the
#' signatures generated by SignatureAnalyzer and second argument
#' the file to write to.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param overwrite If TRUE overwrite previous results in same directory tree.
#'
#' @param mc.cores Number of cores to use for \code{mclapply}; ignored on
#' Windows.
#'
#' @param verbose If TRUE cat a message regarding progress.
#'
#' @importFrom parallel mclapply
#'
#' @export
SAMultiRunOneCatalog <-
  function(num.runs,
           signatureanalyzer.code.dir,
           input.catalog,
           read.catalog.function,
           out.dir,
           write.signature.function,
           maxK = 30,
           tol = 1e-7,
           test.only = FALSE,
           delete.tmp.files = TRUE,
           overwrite = FALSE,
           mc.cores = 1,
           verbose = FALSE) {

    if (!dir.exists(out.dir)) dir.create(out.dir)
    else warning(out.dir, "exists, overwriting")

    RunOneIndex <- function(i) {
      out.dir2 <- paste0(out.dir, "sa.run.", i)
      signature.analyzer.output <-
        SignatureAnalyzerOneRun(
          signatureanalyzer.code.dir = signatureanalyzer.code.dir,
          input.catalog = input.catalog,
          read.catalog.function = read.catalog.function,
          out.dir = out.dir2,
          write.signature.function = write.signature.function,
          maxK = maxK,
          tol = tol,
          test.only = test.only,
          delete.tmp.files = delete.tmp.files,
          overwrite = overwrite)
      attr(signature.analyzer.output, "message") <-
        paste0("Success for ", out.dir2)
      return(signature.analyzer.output)
    }

    mc.cores.to.use <-
      ifelse(Sys.info()["sysname"] == "Windows", 1, mc.cores)

    if (verbose) {
      cat("Using", mc.cores.to.use, " cores\n")
    }

    mc.output <-
      mclapply(1:num.runs, FUN = RunOneIndex, mc.cores = mc.cores.to.use)

    capture.output(
      print(mc.output),
      file = paste0(out.dir, "/verbose.txt"))

    attr(mc.output, "wd") <- getwd()
    attr(mc.output, "out.dir") <- out.dir
    attr(mc.output, "mc.cores") <- mc.cores.to.use
    return(mc.output)
  }

#' Run SignatureAnalyzer on 4 coordinated data sets and put results
#' in specified location.
#'
#' @details The 4 coordinated data sets are
#'
#' \enumerate{
#' \item \code{sa.sa.96}
#'
#' \item \code{sp.sp}
#'
#' \item \code{sa.sa.COMPOSITE}
#'
#' \item \code{sp.sa.COMPOSITE}
#'
#' }
#' which are described elsewhere.
#'
#'
#' @param num.runs Number of SignatureAnalyzer runs per data set.
#'
#' @param signatureanalyzer.code.dir The directory holding the
#' SignatureAnalyzer code.
#'
#' @param dir.root Root of directory tree that contains the
#' input data and to which the results will be written.
#'
#' @param maxK The maximum number of signatures to consider
#' extracting.
#'
#' @param tol Controls when SignatureAnalyzer will terminate
#' its search; \code{tol} was 1.e-05 for the PCAWG7 analysis.
#'
#' @param test.only If TRUE, only analyze the first 10 columns
#' read in from \code{input.catalog}.
#'
#' @param delete.tmp.files If TRUE delete the many temporary
#'  files generated by SignatureAnalyzer.
#'
#' @param slice Vector of integers from 1:4. Only run on the
#' corresponding data set (see Details).
#'
#' @param overwrite if TRUE overwrite preexisting results.
#'
#' @param mc.cores The number of cores to use with \code{mclapply};
#' ignored on Windows.
#'
#' @export
#'
#' @importFrom ICAMS WriteCatSNS96 ReadCatSNS96

SignatureAnalyzer4MatchedCatalogs <-
  function(
    num.runs = 20,
    signatureanalyzer.code.dir,
    dir.root,
    maxK = 30,
    tol = 1e-7,
    test.only = FALSE,
    delete.tmp.files = TRUE,
    slice = 1:4,
    overwrite = FALSE,
    mc.cores = 1) {

    if (!dir.exists(dir.root)) stop(dir.root, "does not exist")

    subdirs <- c("sa.sa.96", "sp.sp", "sa.sa.COMPOSITE", "sp.sa.COMPOSITE")
    read.fn <- c(ReadCatSNS96, ReadCatSNS96, ReadCatCOMPOSITE, ReadCatCOMPOSITE)
    write.fn <- c(WriteCatSNS96, WriteCatSNS96, WriteCatCOMPOSITE, WriteCatCOMPOSITE)

    tmp.fn <- function(subdir, read.fn, write.fn) {
      retval1 <-
        SAMultiRunOneCatalog(
          num.runs = num.runs,
          signatureanalyzer.code.dir = signatureanalyzer.code.dir,
          input.catalog = paste0(dir.root, "/", subdir, "/ground.truth.syn.catalog.csv"),
          read.catalog.function = read.fn,
          out.dir = paste0(dir.root, "/", subdir, "/sa.results/"),
          write.signature.function = write.fn,
          maxK = maxK,
          tol = tol,
          test.only = test.only,
          delete.tmp.files = delete.tmp.files,
          overwrite = overwrite,
          mc.cores = mc.cores)
      return(retval1)
    }

  retval2 <-
    mapply(tmp.fn, subdirs[slice], read.fn[slice], write.fn[slice])

  invisible(retval2)
  }
